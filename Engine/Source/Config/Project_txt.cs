/* 
 * Class: CodeClear.NaturalDocs.Engine.Config.Project_txt
 * ____________________________________________________________________________
 * 
 * A class to handle loading and saving <Project.txt>.
 * 
 * 
 * Threading: Not Thread Safe
 * 
 *		The parser object may be reused, but multiple threads cannot use it at the same time.
 *		
 * 
 * File: Project.txt
 * 
 *		The configuration file that defines the project settings for Natural Docs.  Various settings may be overridden by the command
 *		line, though.
 *		
 * 
 *		Project Information:
 *		
 *			> Title: [title]
 *			> Subtitle: [subtitle]
 *			> Copyright: [copyright]
 *
 *			The title, subtitle, and copyright notice for the project.  (C), (R), and (TM) will be converted into their respective symbols.
 *			
 *			> Timestamp: [timestamp code]
 *			
 *			The timestamp code is a regular string with the following subsitutions performed:
 *			
 *				m - Single digit month, when possible.  January is "1".
 *				mm - Always double digit month.  January is "01".
 *				mon - Short month word.  January is "Jan".
 *				month - Long month word.  January is "January".
 *				d - Single digit day, when possible.  1 is "1".
 *				dd - Always double digit day.  1 is "01".
 *				day - Day with text extension.  1 is "1st".
 *				yy - Double digit year.  2013 is "13".
 *				yyyy - Four digit year.  2013 is "2013".
 *				year - Four digit year.  2013 is "2013".
 *			
 *			Anything else is left literal in the output.  The substitution requires a non-letter on each side, so every m will not turn into
 *			the month.
 *			
 *			> Style: [name]
 *			
 *			The style to apply to all output entries.
 *			
 * 
 *		Input Entries:
 * 
 *			> Source Folder: [path]
 *			> Source Folder [number]: [path]
 *			>    Name: [name]
 *				
 *			Specifies a source folder.  Relative paths are relative to the project folder.
 *			
 *			A number can optionally be specified.  If none is, it uses the lowest number not in use by another entry.  Each source
 *			entry must have a unique number.
 *			
 *			Name can optionally be specified.  It's not required if there is only one source folder.  If there's more than one and it's 
 *			not specified it will be autogenerated.
 *			
 *			> Image Folder: [path]
 *			> Image Folder [number]: [path]
 *			
 *			Specifies an image folder.  Relative paths are relative to the project folder.
 *			
 *			A number can optionally be specified.  If none is, it uses the lowest number not in use by another entry.  Each image
 *			entry must have a unique number.
 *			
 * 
 *		Filter Entries:
 *		
 *			> Ignore Source Folder: [path]
 *			
 *			Specifies a source folder that should not be scanned for files.  Relative paths are relative to the project folder.
 *			
 *			> Ignore Source Folder Pattern: [pattern]
 *			
 *			Specifies a pattern that should cause a source folder to be ignored if it matches.  ? matches a single character, * matches 
 *			zero or more characters.  It applies to the entire folder name, so "cli" will not match "client", although "cli*" will.
 *			
 * 
 *		Output Entries:
 * 
 *			> HTML Output Folder: [path]
 *			>    [Project Info Settings]
 *			
 *			Specifies a HTML output folder.  Relative paths are relative to the project folder.
 *			
 *			Each folder may override any of the project information settings if desired.  This allows projects with multiple output targets
 *			to give each one its own style, subtitle, etc.
 *			
 *			Although internally output entries have numbers like input entries, they're not stored in this file because it's not important
 *			for them to remain consistent from one computer to the next.  They're only used for temporary data, whereas input entry
 *			numbers affect the generated output file paths (/files2, etc.) and thus need to remain consistent so URLs don't constantly
 *			change.
 *			
 * 
 *		Global Settings:
 * 
 *			> Tab Width: [width]
 *			
 *			The number of spaces a tab should be expanded to.
 *			
 *			> Documented Only: [yes|no]
 *			
 *			Whether only documented code elements should appear in the output.
 *			
 *			> Auto Group: [yes|no]
 *			
 *			Whether automatic grouping should be applied.
 *			
 * 
 *		Revisions:
 * 
 *		2.0:
 *		
 *			The initial version of this file.
 *		
 */

// This file is part of Natural Docs, which is Copyright © 2003-2020 Code Clear LLC.
// Natural Docs is licensed under version 3 of the GNU Affero General Public License (AGPL)
// Refer to License.txt for the complete details


using System;
using System.Text;
using CodeClear.NaturalDocs.Engine.Config;
using CodeClear.NaturalDocs.Engine.Errors;


namespace CodeClear.NaturalDocs.Engine.Config
	{
	public class Project_txt
		{
		
		// Group: Functions
		// __________________________________________________________________________
		
		
		/* Constructor: Project_txt
		 */
		public Project_txt ()
			{
			errorList = null;
			projectConfig = null;

			yesRegex = new Regex.Config.Yes();
			noRegex = new Regex.Config.No();
							
			subtitleRegex = new Regex.Config.Subtitle();
			timestampRegex = new Regex.Config.Timestamp();
			tabWidthRegex = new Regex.Config.TabWidth();
			documentedOnlyRegex = new Regex.Config.DocumentedOnly();
			autoGroupRegex = new Regex.Config.AutoGroup();

			sourceFolderRegex = new Regex.Config.SourceFolder();
			imageFolderRegex = new Regex.Config.ImageFolder();
			htmlOutputFolderRegex = new Regex.Config.HTMLOutputFolder();
			ignoredSourceFolderRegex = new Regex.Config.IgnoredSourceFolder();
			ignoredSourceFolderPatternRegex = new Regex.Config.IgnoredSourceFolderPattern();
			}



		// Group: Loading Functions
		// __________________________________________________________________________


		/* Function: Load
		 * Attempts to parse <Project.txt> and return it as a <ProjectConfig>.  Any syntax errors found will be added to the
		 * <ErrorList>.  The <ProjectConfig> object will always exist, even if all its properties are empty.
		 */
		public bool Load (Path path, out ProjectConfig projectConfig, ErrorList errorList)
			{
			projectConfig = new ProjectConfig(Source.ProjectFile);

			this.errorList = errorList;
			this.projectConfig = projectConfig;

			int originalErrorCount = errorList.Count;

			using (var configFile = new ConfigFile())
				{
				// We don't condense value whitespace because some things like title, subtitle, and copyright may want multiple spaces.
				bool openResult = configFile.Open(path, 
															  ConfigFile.FileFormatFlags.CondenseIdentifierWhitespace |
															  ConfigFile.FileFormatFlags.MakeIdentifiersLowercase,
															  errorList);
														 
				if (openResult == false)
					{  return false;  }

				string lcIdentifier, value;
				
				Targets.Base currentTarget =  null;
				ProjectInfo currentProjectInfo = projectConfig.ProjectInfo;

				while (configFile.Get(out lcIdentifier, out value))
					{
					var propertyLocation = new PropertyLocation(Source.ProjectFile, configFile.FileName, configFile.LineNumber);
					Targets.Base target = null;

					if (GetGlobalProperty(lcIdentifier, value, propertyLocation))
						{
						currentTarget = null;
						currentProjectInfo = projectConfig.ProjectInfo;
						}
					else if (GetTargetHeader(lcIdentifier, value, propertyLocation, out target))
						{
						currentTarget = target;

						if (target is Targets.OutputBase)
							{  currentProjectInfo = (target as Targets.OutputBase).ProjectInfo;  }
						else
							{  currentProjectInfo = projectConfig.ProjectInfo;  }
						}
					else if (GetProjectInfoProperty(lcIdentifier, value, propertyLocation, currentProjectInfo))
						{  }
					else if (currentTarget != null && GetTargetProperty(lcIdentifier, value, propertyLocation, currentTarget))
						{  }
					else
						{
						errorList.Add (
							message: Locale.Get("NaturalDocs.Engine", "ConfigFile.NotAValidIdentifier(identifier)", lcIdentifier),
							propertyLocation: propertyLocation
							);
						}
					}
				
				configFile.Close();
				}
				
			return (errorList.Count == originalErrorCount);
			}


		/* Function: GetGlobalProperty
		 * If the passed identifier is a global property like Tab Width, adds it to <projectConfig> and returns true.  If it is a recognized
		 * global property but has a syntax error in the value, it will add an error to <errorList> and still return true.  It only returns
		 * false on unrecognized identifiers.
		 */
		protected bool GetGlobalProperty (string lcIdentifier, string value, PropertyLocation propertyLocation)
			{
			if (tabWidthRegex.IsMatch(lcIdentifier))
				{
				int tabWidth = 0;
						
				if (Int32.TryParse(value, out tabWidth) == true)
					{  
					projectConfig.TabWidth = tabWidth;
					projectConfig.TabWidthPropertyLocation = propertyLocation;
					}
				else
					{
					errorList.Add( Locale.Get("NaturalDocs.Engine", "Error.TabWidthMustBeANumber"), 
									   propertyLocation.FileName, propertyLocation.LineNumber );
					}

				return true;
				}

			else if (documentedOnlyRegex.IsMatch(lcIdentifier))
				{
				if (yesRegex.IsMatch(value))
					{  
					projectConfig.DocumentedOnly = true;  
					projectConfig.DocumentedOnlyPropertyLocation = propertyLocation;
					}
				else if (noRegex.IsMatch(value))
					{  
					projectConfig.DocumentedOnly = false;
					projectConfig.DocumentedOnlyPropertyLocation = propertyLocation;
					}
				else
					{
					errorList.Add( Locale.Get("NaturalDocs.Engine", "Project.txt.UnrecognizedValue(keyword, value)", "Documented Only", value),
									   propertyLocation.FileName, propertyLocation.LineNumber );
					}

				return true;
				}

			else if (autoGroupRegex.IsMatch(lcIdentifier))
				{
				if (yesRegex.IsMatch(value))
					{  
					projectConfig.AutoGroup = true;  
					projectConfig.AutoGroupPropertyLocation = propertyLocation;
					}
				else if (noRegex.IsMatch(value))
					{  
					projectConfig.AutoGroup = false;  
					projectConfig.AutoGroupPropertyLocation = propertyLocation;
					}
				else
					{
					errorList.Add( Locale.Get("NaturalDocs.Engine", "Project.txt.UnrecognizedValue(keyword, value)", "Auto Group", value),
									   propertyLocation.FileName, propertyLocation.LineNumber );
					}

				return true;
				}

			else
				{
				return false;
				}
			}


		/* Function: GetProjectInfoProperty
		 * If the passed identifier is a project info property like Title, adds it to <currentProjectInfo> and returns true.  If it is a recognized
		 * project info property but there's a syntax error in the value, it will add an error to <errorList> and still return true.  It only returns
		 * false for unrecognized identifiers.
		 */
		protected bool GetProjectInfoProperty (string lcIdentifier, string value, PropertyLocation propertyLocation, ProjectInfo projectInfo)
			{
			if (lcIdentifier == "title")
				{
				projectInfo.Title = value.ConvertCopyrightAndTrademark();
				projectInfo.TitlePropertyLocation = propertyLocation;
				return true;
				}
			else if (subtitleRegex.IsMatch(lcIdentifier))
				{
				projectInfo.Subtitle = value.ConvertCopyrightAndTrademark();
				projectInfo.SubtitlePropertyLocation = propertyLocation;
				return true;
				}
			else if (lcIdentifier == "copyright")
				{
				projectInfo.Copyright = value.ConvertCopyrightAndTrademark();
				projectInfo.CopyrightPropertyLocation = propertyLocation;
				return true;
				}
			else if (timestampRegex.IsMatch(lcIdentifier))
				{
				projectInfo.TimestampCode = value;
				projectInfo.TimestampCodePropertyLocation = propertyLocation;
				return true;
				}
			else if (lcIdentifier == "style")
				{
				projectInfo.StyleName = value;
				projectInfo.StyleNamePropertyLocation = propertyLocation;
				return true;
				}
			else
				{
				return false;
				}
			}


		/* Function: GetTargetHeader
		 * If the passed identifier starts a target like "Source Folder", adds a new target for it in <projectConfig> and returns true.  If 
		 * it is a recognized target header but there is a syntax error in the value, it will add an error to <errorList> and still return true.
		 * It only returns false for unrecognized identifiers.
		 */
		protected bool GetTargetHeader (string lcIdentifier, string value, PropertyLocation propertyLocation, out Targets.Base newTarget)
			{

			// Source folder

			System.Text.RegularExpressions.Match match = sourceFolderRegex.Match(lcIdentifier);

			if (match.Success)
				{
				var target = new Targets.SourceFolder(propertyLocation, Files.InputType.Source);

				target.Folder = value;
				target.FolderPropertyLocation = propertyLocation;

				if (target.Folder.IsRelative)
					{  target.Folder = propertyLocation.FileName.ParentFolder + "/" + target.Folder;  }

				int number = 0;

				if (int.TryParse(match.Groups[1].Value, out number))
					{  
					target.Number = number;
					target.NumberPropertyLocation = propertyLocation;
					}

				projectConfig.InputTargets.Add(target);
				newTarget = target;
				return true;
				}
				

			// Image folder

			match = imageFolderRegex.Match(lcIdentifier);

			if (match.Success)
				{  
				var target = new Targets.SourceFolder(propertyLocation, Files.InputType.Image);

				target.Folder = value;
				target.FolderPropertyLocation = propertyLocation;

				if (target.Folder.IsRelative)
					{  target.Folder = propertyLocation.FileName.ParentFolder + "/" + target.Folder;  }

				int number = 0;

				if (int.TryParse(match.Groups[1].Value, out number))
					{  
					target.Number = number;
					target.NumberPropertyLocation = propertyLocation;
					}

				projectConfig.InputTargets.Add(target);
				newTarget = target;
				return true;
				}


			// HTML output folder
				
			else if (htmlOutputFolderRegex.IsMatch(lcIdentifier))
				{  
				var target = new Targets.HTMLOutputFolder(propertyLocation);

				target.Folder = value;
				target.FolderPropertyLocation = propertyLocation;

				if (target.Folder.IsRelative)
					{  target.Folder = propertyLocation.FileName.ParentFolder + "/" + target.Folder;  }

				projectConfig.OutputTargets.Add(target);
				newTarget = target;
				return true;
				}


			// Ignored source folder
				
			else if (ignoredSourceFolderRegex.IsMatch(lcIdentifier))
				{  
				var target = new Targets.IgnoredSourceFolder(propertyLocation);

				target.Folder = value;
				target.FolderPropertyLocation = propertyLocation;

				if (target.Folder.IsRelative)
					{  target.Folder = propertyLocation.FileName.ParentFolder + "/" + target.Folder;  }

				projectConfig.FilterTargets.Add(target);
				newTarget = target;
				return true;
				}
				

			// Ignored source folder pattern
				
			else if (ignoredSourceFolderPatternRegex.IsMatch(lcIdentifier))
				{  
				var target = new Targets.IgnoredSourceFolderPattern(propertyLocation);

				target.Pattern = value;
				target.PatternPropertyLocation = propertyLocation;

				projectConfig.FilterTargets.Add(target);
				newTarget = target;
				return true;
				}
				

			else
				{  
				newTarget = null;
				return false;  
				}
		    }


		/* Function: GetTargetProperty
		 * If the passed identifier is a valid keyword for <currentTarget>, applies the property and returns true.  This does not cover
		 * the <ProjectInfo> settings for output targets, use <GetProjectInfoProperty()> for that instead.  If the value is invalid it will 
		 * add an error to <errorList> and still return true.  It will only return false if the identifier is unrecognized.
		 */
		protected bool GetTargetProperty (string lcIdentifier, string value, PropertyLocation propertyLocation, Targets.Base target)
			{
			if (lcIdentifier == "name")
				{
				 if (target is Targets.SourceFolder && 
					(target as Targets.SourceFolder).Type == Files.InputType.Source)
					{
					(target as Targets.SourceFolder).Name = value;
					(target as Targets.SourceFolder).NamePropertyLocation = propertyLocation;
					}
				else
					{
					errorList.Add( Locale.Get("NaturalDocs.Engine", "Project.txt.NameOnlyAppliesToSourceFolders"),
									   propertyLocation.FileName, propertyLocation.LineNumber );
					}

				return true;
				}
				
			else
				{  return false;  }
			}



		// Group: Saving Functions
		// __________________________________________________________________________


		/* Function: Save
		 * 
		 * Saves the passed <ConfigData> into <Project.txt>, returning whether it was successful.  It will automatically skip
		 * properties that shouldn't be saved into the file.
		 * 
		 * Property Source:
		 * 
		 *		<Source.SystemDefault> - Will never be saved into <Project.txt>.
		 *		
		 *		<Source.SystemGenerated> - Will always be saved into <Project.txt>.  This allows things like source folder names and
		 *												 numbers to be written into <Project.txt> so that they remain consistent between runs
		 *												 and so it's easy for the user to edit them.
		 *												 
		 *		<Source.CommandLine> - Global properties will not be saved into <Project.txt> so that settings don't get tattooed into
		 *										   place.  If someone specifies Documented Only on the command line it should turn off when
		 *										   they take it off the command line.  They shouldn't have to edit <Project.txt> as well.
		 *										   
		 *										   Targets and their associated properties will be saved into <Project.txt>.  This allows a
		 *										   <Project.txt> file to be generated from the command line so we can store secondary target
		 *										   settings.  Since <Project.txt> targets are ignored except for secondary settings when they're
		 *										   specified on the command line, tattooing is less of an issue.
		 */
		public bool Save (Path path, ProjectConfig projectConfig, Errors.ErrorList errorList)
			{
			this.projectConfig = projectConfig;
			this.errorList = errorList;

			StringBuilder output = new StringBuilder(1024);
			Path projectFolder = path.ParentFolder;
			
			output.AppendLine("Format: " + Engine.Instance.VersionString);
			output.AppendLine();

			AppendFileHeader(output);			
			
			AppendGlobalProjectInfo(output);
			AppendInputTargets(output, projectFolder);
			AppendFilterTargets(output, projectFolder);
			AppendOutputTargets(output, projectFolder);
			AppendGlobalSettings(output);
			
			return ConfigFile.SaveIfDifferent(path, output.ToString(), false, errorList);
			}


		/* Function: AppendFileHeader
		 * Appends the general file header to the passed string.
		 */
		protected void AppendFileHeader (StringBuilder output)
			{
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.FileHeader.multiline") );
			output.AppendLine();
			output.AppendLine();
			}


		/* Function: AppendGlobalProjectInfo
		 * Appends the global <ProjectInfo> in <projectConfig> to the passed string.
		 */
		protected void AppendGlobalProjectInfo (StringBuilder output)
			{

			// Header

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.ProjectInfoHeader.multiline") );
			output.AppendLine();


			// Defined values

			bool hasTitle = (projectConfig.ProjectInfo.TitlePropertyLocation.IsDefined &&
								  projectConfig.ProjectInfo.TitlePropertyLocation.Source != Source.SystemDefault &&
								  projectConfig.ProjectInfo.TitlePropertyLocation.Source != Source.CommandLine);
			bool hasSubtitle = (projectConfig.ProjectInfo.SubtitlePropertyLocation.IsDefined &&
									  projectConfig.ProjectInfo.SubtitlePropertyLocation.Source != Source.SystemDefault &&
									  projectConfig.ProjectInfo.SubtitlePropertyLocation.Source != Source.CommandLine);
			bool hasCopyright = (projectConfig.ProjectInfo.CopyrightPropertyLocation.IsDefined &&
										projectConfig.ProjectInfo.CopyrightPropertyLocation.Source != Source.SystemDefault &&
										projectConfig.ProjectInfo.CopyrightPropertyLocation.Source != Source.CommandLine);
			bool hasTimestampCode = (projectConfig.ProjectInfo.TimestampCodePropertyLocation.IsDefined &&
												 projectConfig.ProjectInfo.TimestampCodePropertyLocation.Source != Source.SystemDefault &&
												 projectConfig.ProjectInfo.TimestampCodePropertyLocation.Source != Source.CommandLine);
			bool hasStyleName = (projectConfig.ProjectInfo.StyleNamePropertyLocation.IsDefined &&
										  projectConfig.ProjectInfo.StyleNamePropertyLocation.Source != Source.SystemDefault &&
										  projectConfig.ProjectInfo.StyleNamePropertyLocation.Source != Source.CommandLine);

			if (hasTitle)
				{  
				output.AppendLine("Title: " + projectConfig.ProjectInfo.Title);

				if (!hasSubtitle)
					{  output.AppendLine();  }
				}
					
			if (hasSubtitle)
				{
				output.AppendLine("Subtitle: " + projectConfig.ProjectInfo.Subtitle);
				output.AppendLine();
				}
					
			if (hasCopyright)
				{
				output.AppendLine("Copyright: " + projectConfig.ProjectInfo.Copyright);
				output.AppendLine();
				}
			
			if (hasTimestampCode)
				{  
				output.AppendLine("Timestamp: " + projectConfig.ProjectInfo.TimestampCode);
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.TimestampSubstitutions.multiline") );
				output.AppendLine();
				}

			if (hasStyleName)
				{
				output.AppendLine("Style: " + projectConfig.ProjectInfo.StyleName);
				output.AppendLine();
				}

			if (hasTitle || hasSubtitle || hasCopyright || hasTimestampCode || hasStyleName)
				{  output.AppendLine();  }


			// Syntax reference

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.ProjectInfoHeaderText.multiline") );

			if (!hasTitle)
				{
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.TitleSyntax.multiline") );
				}
					
			if (!hasSubtitle)
				{  
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.SubtitleSyntax.multiline") );
				}
					
			if (!hasCopyright)
				{  
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.CopyrightSyntax.multiline") );
				}
			
			if (!hasTimestampCode)
				{  
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.TimestampSyntax.multiline") );
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.TimestampSubstitutions.multiline") );
				}

			if (!hasStyleName)
				{
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.StyleSyntax.multiline") );
				}

			output.AppendLine();
			output.AppendLine();
			}


		/* Function: AppendOverriddenProjectInfo
		 * Appends the overridden <ProjectInfo> to the passed string.
		 */
		protected void AppendOverriddenProjectInfo (ProjectInfo projectInfo, StringBuilder output)
			{
			if (projectInfo.TitlePropertyLocation.IsDefined &&
				projectInfo.TitlePropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Title: " + projectInfo.Title);  }
					
			if (projectInfo.SubtitlePropertyLocation.IsDefined &&
				projectInfo.SubtitlePropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Subtitle: " + projectInfo.Subtitle);  }
					
			if (projectInfo.CopyrightPropertyLocation.IsDefined &&
				projectInfo.CopyrightPropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Copyright: " + projectInfo.Copyright);  }
			
			if (projectInfo.TimestampCodePropertyLocation.IsDefined &&
				projectInfo.TimestampCodePropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Timestamp: " + projectInfo.TimestampCode);  }

			if (projectInfo.StyleNamePropertyLocation.IsDefined &&
				projectInfo.StyleNamePropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Style: " + projectInfo.StyleName);   }
			}


		/* Function: AppendInputTargets
		 * Appends all input targets in <projectConfig> to the passed StringBuilder.
		 */
		protected void AppendInputTargets (StringBuilder output, Path projectFolder)
			{
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.InputHeader.multiline") );
			output.AppendLine();

			int appended = 0;


			// Put source folders before image folders

			foreach (var target in projectConfig.InputTargets)
				{
				// We save input targets even if they're specified on the command line so we can still use Project.txt for secondary
				// settings.
				if (target.PropertyLocation.Source != Source.SystemDefault)
					{
					if (target is Targets.SourceFolder &&
						target.Type == Files.InputType.Source)
						{  
						AppendSourceFolder((Targets.SourceFolder)target, output, projectFolder);

						output.AppendLine();
						appended++;
						}
					}
				}

			foreach (var target in projectConfig.InputTargets)
				{
				if (target.PropertyLocation.Source != Source.SystemDefault)
					{
					if (target is Targets.SourceFolder)
						{
						if (target.Type == Files.InputType.Image)
							{  AppendSourceFolder((Targets.SourceFolder)target, output, projectFolder);  }
						else if (target.Type != Files.InputType.Source)
							{  throw new NotImplementedException();  }
						}
					else
						{  throw new NotImplementedException();  }

					output.AppendLine();
					appended++;
					}
				}

			if (appended > 0)
				{  output.AppendLine();  }

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.InputHeaderText.multiline") );
			output.AppendLine("#");
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.SourceFolderSyntax.multiline") );
			//output.AppendLine("#");
			//output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.ImageFolderSyntax.multiline") );
			output.AppendLine();
			output.AppendLine();
			}


		/* Function: AppendSourceFolder
		 * Appends a source folder target and all its settings to the StringBuilder.
		 */
		protected void AppendSourceFolder (Targets.SourceFolder target, StringBuilder output, Path projectFolder)
			{
			if (target.PropertyLocation.Source == Source.SystemDefault)
				{  return;  }

			if (target.Type == Files.InputType.Source)
				{  output.Append("Source");  }
			else if (target.Type == Files.InputType.Image)
				{  output.Append("Image");  }
			else
				{  throw new NotImplementedException();  }

			output.Append(" Folder");

			if (target.NumberPropertyLocation.IsDefined &&
				target.NumberPropertyLocation.Source != Source.SystemDefault &&
				target.Number != 1)
				{  output.Append(" " + target.Number);  }

			output.Append(": ");

			Path relativePath = target.Folder.MakeRelativeTo(projectFolder);
			output.AppendLine( (relativePath != null ? relativePath : target.Folder) );

			if (target.NamePropertyLocation.IsDefined &&
				target.NamePropertyLocation.Source != Source.SystemDefault)
				{  output.AppendLine("   Name: " + target.Name);  }
			}


		/* Function: AppendFilterTargets
		 * Appends all filter targets in <projectConfig> to the passed StringBuilder.
		 */
		protected void AppendFilterTargets (StringBuilder output, Path projectFolder)
			{
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.FilterHeader.multiline") );
			output.AppendLine();

			int appended = 0;

			foreach (var target in projectConfig.FilterTargets)
				{
				// We save filter targets even if they're specified on the command line so we can still use Project.txt for secondary
				// settings.
				if (target.PropertyLocation.Source != Source.SystemDefault)
					{
					if (target is Targets.IgnoredSourceFolder)
						{  AppendIgnoredSourceFolder((Targets.IgnoredSourceFolder)target, output, projectFolder);  }
					else if (target is Targets.IgnoredSourceFolderPattern)
						{  AppendIgnoredSourceFolderPattern((Targets.IgnoredSourceFolderPattern)target, output);  }
					else
						{  throw new NotImplementedException();  }

					output.AppendLine();
					appended++;
					}
				}

			if (appended > 0)
				{  output.AppendLine();  }

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.FilterHeaderText.multiline") );
			output.AppendLine("#");
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.IgnoreSourceFolderSyntax.multiline") );
			output.AppendLine("#");
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.IgnoreSourceFolderPatternSyntax.multiline") );
			output.AppendLine();
			output.AppendLine();
			}


		/* Function: AppendIgnoredSourceFolder
		 * Appends an ignored source folder target and all its settings to the passed StringBuilder.
		 */
		protected void AppendIgnoredSourceFolder (Targets.IgnoredSourceFolder target, StringBuilder output, Path projectFolder)
			{
			if (target.PropertyLocation.Source == Source.SystemDefault)
				{  return;  }

			output.Append("Ignore Source Folder: ");

			Path relativePath = target.Folder.MakeRelativeTo(projectFolder);
			output.AppendLine( (relativePath != null ? relativePath : target.Folder) );
			}


		/* Function: AppendIgnoredSourceFolderPattern
		 * Appends an ignored source folder pattern target and all its settings to the passed StringBuilder.
		 */
		protected void AppendIgnoredSourceFolderPattern (Targets.IgnoredSourceFolderPattern target, StringBuilder output)
			{
			if (target.PropertyLocation.Source == Source.SystemDefault)
				{  return;  }

			output.AppendLine("Ignore Source Folder Pattern: " + target.Pattern);
			}


		/* Function: AppendOutputTargets
		 * Appends all output targets in <projectConfig> to the passed StringBuilder.
		 */
		protected void AppendOutputTargets (StringBuilder output, Path projectFolder)
			{
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.OutputHeader.multiline") );
			output.AppendLine();

			int appended = 0;

			foreach (var target in projectConfig.OutputTargets)
				{
				// We save output targets even if they're specified on the command line so we can still use Project.txt for secondary
				// settings.
				if (target.PropertyLocation.Source != Source.SystemDefault)
					{
					if (target is Targets.HTMLOutputFolder)
						{  AppendHTMLOutputFolder((Targets.HTMLOutputFolder)target, output, projectFolder);  }
					else
						{  throw new NotImplementedException();  }

					output.AppendLine();
					appended++;
					}
				}

			if (appended > 0)
				{  output.AppendLine();  }

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.OutputHeaderText.multiline") );
			output.AppendLine("#");
			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.HTMLOutputFoldersSyntax.multiline") );
			output.AppendLine();
			output.AppendLine();
			}


		protected void AppendHTMLOutputFolder (Targets.HTMLOutputFolder target, StringBuilder output, Path projectFolder)
			{
			if (target.PropertyLocation.Source == Source.SystemDefault)
				{  return;  }

			output.Append("HTML Output Folder: ");

			Path relativePath = target.Folder.MakeRelativeTo(projectFolder);
			output.AppendLine( (relativePath != null ? relativePath : target.Folder) );

			AppendOverriddenProjectInfo(target.ProjectInfo, output);
			}


		/* Function: AppendGlobalSettings
		 * Appends the global properties in <projectConfig> to the passed string.
		 */
		protected void AppendGlobalSettings (StringBuilder output)
			{

			// Header

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.GlobalSettingsHeader.multiline") );
			output.AppendLine();


			// Defined values

			bool hasTabWidth = (projectConfig.TabWidthPropertyLocation.IsDefined &&
										projectConfig.TabWidthPropertyLocation.Source != Source.SystemDefault &&
										projectConfig.TabWidthPropertyLocation.Source != Source.CommandLine);
			bool hasDocumentedOnly = (projectConfig.DocumentedOnlyPropertyLocation.IsDefined &&
													projectConfig.DocumentedOnlyPropertyLocation.Source != Source.SystemDefault &&
													projectConfig.DocumentedOnlyPropertyLocation.Source != Source.CommandLine);
			bool hasAutoGroup = (projectConfig.AutoGroupPropertyLocation.IsDefined &&
										  projectConfig.AutoGroupPropertyLocation.Source != Source.SystemDefault &&
										  projectConfig.AutoGroupPropertyLocation.Source != Source.CommandLine);
				
			if (hasTabWidth)
				{
				output.AppendLine("Tab Width: " + projectConfig.TabWidth);
				output.AppendLine();
				}

			if (hasDocumentedOnly)
				{
				output.Append("Documented Only: " + (projectConfig.DocumentedOnly ? "Yes" : "No"));
				output.AppendLine();
				}

			if (hasAutoGroup)
				{
				output.Append("Auto Group: " + (projectConfig.AutoGroup ? "Yes" : "No"));
				output.AppendLine();
				}

			if (hasTabWidth || hasDocumentedOnly || hasAutoGroup)
				{  output.AppendLine();  }


			// Syntax reference

			output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.GlobalSettingsHeaderText.multiline") );

			if (!hasTabWidth)
				{
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.TabWidthSyntax.multiline") );
				}
			if (!hasDocumentedOnly)
				{
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.DocumentedOnlySyntax.multiline") );
				}
			if (!hasAutoGroup)
				{
				output.AppendLine("#");
				output.Append( Locale.Get("NaturalDocs.Engine", "Project.txt.AutoGroupSyntax.multiline") );
				}

			output.AppendLine();
			output.AppendLine();
			}



		// Group: Variables
		// __________________________________________________________________________

		protected ErrorList errorList;
		protected ProjectConfig projectConfig;


		// Group: Regular Expressions
		// __________________________________________________________________________

		protected Regex.Config.Yes yesRegex;
		protected Regex.Config.No noRegex;

		protected Regex.Config.Subtitle subtitleRegex;
		protected Regex.Config.Timestamp timestampRegex;
		protected Regex.Config.TabWidth tabWidthRegex;
		protected Regex.Config.DocumentedOnly documentedOnlyRegex;
		protected Regex.Config.AutoGroup autoGroupRegex;

		protected Regex.Config.SourceFolder sourceFolderRegex;
		protected Regex.Config.ImageFolder imageFolderRegex;
		protected Regex.Config.HTMLOutputFolder htmlOutputFolderRegex;
		protected Regex.Config.IgnoredSourceFolder ignoredSourceFolderRegex;
		protected Regex.Config.IgnoredSourceFolderPattern ignoredSourceFolderPatternRegex;
		
		}
	}